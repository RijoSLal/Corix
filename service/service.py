from fastapi import FastAPI ,HTTPException , status
from fastapi.responses import JSONResponse
from mongo import startup_client_db,User,Lab_Params,Wearable_Params,User_info,document
import secrets
import bcrypt
import logging 
from datetime import datetime
from model_retriever import Model_Fetch 
import os
from dotenv import load_dotenv
import numpy as np
import joblib 
os.environ['CUDA_VISIBLE_DEVICES'] = '-1'

app = FastAPI(lifespan=startup_client_db)

logger = logging.getLogger(__name__)


load_dotenv()

LENGTH_API_KEY = 32

tracking_uri = os.getenv("MLFLOW_TRACKING_URI")
lab_model_name = os.getenv("LAB_MODEL_NAME")
lab_model_version = os.getenv("LAB_MODEL_VERSION")
wearable_model_name = os.getenv("WEARABLE_MODEL_NAME")
wearable_model_version = os.getenv("WEARABLE_MODEL_VERSION")

FETCH_MODELS = Model_Fetch(tracking_uri)

LAB_MODEL = FETCH_MODELS.load_lab_model(lab_model_name,lab_model_version)
WEAR_MODEL = FETCH_MODELS.load_wearable_model(wearable_model_name,wearable_model_version)

scaler = joblib.load("scaler_used_for_lab_model.pkl")

def create_api_key() -> str:
    """
    Generate a secure random API key using URL-safe base64 encoding.

    Returns:
        str: A secure API key string.
    """
    return secrets.token_urlsafe(LENGTH_API_KEY)

def encrypt_password(password : str) -> str:
    """
    Hash a plaintext password using bcrypt.

    Args:
        password (str): The plaintext password.

    Returns:
        str: The bcrypt hashed password.
    """
    salt = bcrypt.gensalt()
    hashed = bcrypt.hashpw(password.encode(), salt)
    return hashed.decode()

def verify_password(password: str, hashed: str) -> bool:
    """
    Verify if a plaintext password matches a bcrypt hashed password.

    Args:
        password (str): The plaintext password.
        hashed (str): The hashed password.

    Returns:
        bool: True if the password matches the hash, False otherwise.
    """
    return bcrypt.checkpw(password.encode(), hashed.encode())

def is_eligible(api_key: str) -> dict:
    """
    Check if a user exists with the provided API key.

    Args:
        api_key (str): The API key to verify.

    Returns:
        dict: The user document if found, otherwise None.
    """
    result =  app.collections.find_one({
         "api_key":api_key
    })
    return result

def tokens_limit_and_userdata_logs(usage_log: list,usage_index: int,readings: list,prediction: list) -> int:
    """
    Manage the usage log and rotate it on a circular buffer basis.

    Args:
        usage_log (list): List containing the last 12 logs.
        usage_index (int): The current index in the log.
        readings (list): Input data for prediction.
        prediction (list): Model's prediction result.

    Returns:
        int: The next index to write the log to.
    """
   

    if usage_log is None or not isinstance(usage_log, list) or len(usage_log) != 12:
        usage_log = [{} for _ in range(12)]
        usage_index = 0

    usage_log[usage_index] = {
        "timestamp": datetime.utcnow().isoformat(),
        "prediction": prediction,
        "data": readings
    }

    next_index = (usage_index + 1) % 12
    return usage_log, next_index

def lab_data_preprocessing(readings:list) -> np.ndarray:
    """
    Preprocess lab data using a fitted scaler.

    Args:
        readings (list): Raw input features for lab model.

    Returns:
        np.ndarray: Scaled input data as a numpy array.
    """
    x_scaled = scaler.transform(readings)
    x = np.array(x_scaled, dtype=np.float32) 
    return x

def wearable_data_preprocessing(data: list) -> list:
    """
    Dummy preprocessing for wearable data for future use

    Args:
        data (list): Input wearable data.

    Returns:
        list: The same data (placeholder).
    """
    return data
@app.get("/")
async def documentation() -> JSONResponse:
    """
    Root endpoint that provides basic information about the API
    and links to the autogenerated documentation.

    Returns:
        JSONResponse: Basic API info with links to Swagger and ReDoc.
    """
    return JSONResponse(
            status_code=200,
            content={
               "documentation" : document
            }
        )

@app.post("/register")
async def register_device(user : User) -> JSONResponse:
        """
        Register a new user and generate an API key.

        Args:
            user (User): User registration data.

        Returns:
            JSONResponse: Contains the API key if registration is successful.
        """
        if app.collections.find_one({"username":user.username}):
            raise HTTPException(status_code=400, detail="username already exist")
        if app.collections.find_one({"email":user.email}):
            raise HTTPException(status_code=400, detail="email already exist")
        
        api_key = create_api_key()
        hased_password = encrypt_password(user.password)
        user_data = {
             
             "username": user.username,
             "email":user.email,
             "password":hased_password,
             "api_key":api_key
        }

        app.collections.insert_one(user_data)
        
        return JSONResponse(content={"api_key" : api_key},status_code=status.HTTP_201_CREATED)

@app.post("/user_info")
async def user_details_database_fetch(user_info: User_info) -> JSONResponse:
    """
    Authenticate user by checking username and hashed password.

    Args:
        user_info (User_info): User credentials.

    Returns:
        JSONResponse: User data if authenticated, otherwise error.
    """
    
    # hased_password = encrypt_password(user_info.password)
    user = app.collections.find_one({"username":user_info.username})
    verified = verify_password(user_info.password,user["password"])
    user.pop("_id", None)  
    user.pop("password", None)
    if user and verified:
        return JSONResponse(
            status_code=200,
            content={
                "success": True,
                "user_info": user
            }
        )
    else:
        return JSONResponse(
            status_code=401,
            content={
                "success": False,
                "error": "Unauthorized access"
            }
        )

@app.post("/predict/from-wearables")
async def prediction_from_wearables(Wearable_P : Wearable_Params) -> JSONResponse:
    """
    Generate a prediction based on wearable sensor data.

    Args:
        Wearable_P (Wearable_Params): Wearable input parameters including API key.

    Returns:
        JSONResponse: Model prediction or unauthorized error.
    """
    
    user = is_eligible(Wearable_P.ApiKey)
    if user:
        usage_index = user.get("usage_index", 0)

        fields = [
            "PPG_1", "PPG_2", "PPG_3",
            "ECG_1", "ECG_2", "ECG_3",
            "SCG_1", "SCG_2", "SCG_3",
            "BCG_1", "BCG_2", "BCG_3"
        ]
        
       
        readings = [[getattr(Wearable_P, field) for field in fields]]
        prediction = WEAR_MODEL.predict(readings)

        usage_log = user.get("user_wearable_log")
        usage_index = user.get("usage_index", 0)

        updated_log, next_index = tokens_limit_and_userdata_logs(
            usage_log, usage_index, readings, prediction.tolist()
        )

        app.collections.update_one(
            {"api_key": Wearable_P.ApiKey},
            {
                "$set": {
                    "user_wearable_log": updated_log,
                    "usage_index": next_index
                }
            }
        )
        
        HEART_DISEASE_LABELS = ("No potential heart disease", "Potential heart disease")
        PREDICTION = HEART_DISEASE_LABELS[
                     prediction.tolist()[0]
                     ]
        return JSONResponse(
            status_code=200,
            content={
                "success": True,
                "prediction": PREDICTION
            }
        )  
    else:
        return JSONResponse(
        status_code=401,
        content={
            "success": False,
            "error": "Unauthorized access"
        }
    )

@app.post("/predict/from-lab")
async def prediction_from_lab(Lab_P : Lab_Params):
    """
    Generate a prediction based on lab data.

    Args:
        Lab_P (Lab_Params): Lab input parameters including API key.

    Returns:
        JSONResponse: Model prediction or unauthorized error.
    """
    user = is_eligible(Lab_P.ApiKey)
    if user:

        fields = [
            "Age",
            "Gender",
            "Height",
            "Weight",
            "SystolicBP",
            "DiastolicBP",
            "Cholesterol",
            "Glucose",
            "Smoke",
            "AlcoholIntake",
            "PhysicalActivity", 
            "BMI"
        ]
        

        readings = [[getattr(Lab_P, field) for field in fields]]
        preprocessed = lab_data_preprocessing(readings)
        probability = LAB_MODEL.predict(preprocessed)
        threshold = 0.5
        prediction = int(probability[0][0] >= threshold)

        if prediction == 1:
            explanation = (
                f"The model predicts a {probability[0][0]:.1%} likelihood of heart disease. "
                "This suggests a potential health risk. Consider consulting a medical professional for further evaluation."
            )
        else:
            explanation = (
                f"The model predicts only a {probability[0][0]:.1%} likelihood of heart disease. "
                "This indicates no current signs of potential heart disease based on the provided data."
            )


        user_lab = {
              "timestamp": datetime.utcnow().isoformat(),
              "prediction": prediction,
        }

        app.collections.update_one(
            {"api_key": Lab_P.ApiKey},
            {
                "$set": {
                    "user_lab": user_lab,
                    
                }
            }
        )


        return JSONResponse(
            status_code=200,
            content={
                "success": True,
                "prediction": explanation
            }
        )
    else:
        return JSONResponse(
        status_code=401,
        content={
            "success": False,
            "error": "Unauthorized access"
        }
    )
